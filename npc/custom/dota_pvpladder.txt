//===== eAthena Script =======================================================
//= PVP ladder script with dota announcement ( SQL only )
//===== By: ==================================================================
//= ~AnnieRuru~
//===== Current Version: =====================================================
//= 2.9
//===== Compatible With: =====================================================
//= eAthena SQL 14279, with MySQL 5.1
//===== Description: =========================================================
//= PVP ladder store in SQL table
//= plus anti-sit-killer feature
//===== Topic ================================================================
//= http://www.eathena.ws/board/index.php?showtopic=177918
//===== Additional Comments: =================================================
//= still don't have modify value option, will be done ... in next year ...
//============================================================================

//	add all the maps that you want this script to trigger ... all pvp and event maps perhaps ?
//	but if you already enable "all" maps, then can comment all these
guild_vs1	mapflag	loadevent
guild_vs2	mapflag	loadevent
guild_vs3	mapflag	loadevent
guild_vs4	mapflag	loadevent
guild_vs5	mapflag	loadevent

-	script	DOTAPVP	-1,{
OnInit:
// Config
	set .sound, 0; // soundeffect : 0 - disable, 1 - play soundeffect to all players on map, 2 - play soundeffect to an area around the killer, 3 - play soundeffect to killer only
	set .announce, 0; // announce to : 0 - global, 1 - map
	set .announcemap, 1; // announce the map name in the announcement ? : 0 - off, 1 - on

	set .announcekill, 0; // announce who pawn who's head : 0 - off, 1 - on
	set .msg_die, 0; // show message who kill you when die : 0 - off, 1 - on
	set .msg_kill, 0; // show message you kill who when killed someone : 0 - off, 1 - on

	set .gmnokill, 0; // GMs are not suppose to kill players. A GM with <this number> level or higher will do nothing. IF set to 60, GM60 and above kill any player will not get anything : 0 - off

	set .killingspree, 3;
	set .dominating, 4;
	set .megakill, 5;
	set .unstoppable, 6;
	set .wickedsick, 7;
	set .monsterkill, 8;
	set .godlike, 9;
	set .holyshit, 10;
	set .continue, 1; // after beyond-godlike, every <this number> kills will make announcement again

	set .owned, 5; // how many times the party/guild has to kill to announce ownage
	set .owncontinue, 1; // after ownage, every <this number> party/guild cumulative kills will make ownage announce again

	set .min_gm_menu, 90; // minimum level of GM can use the GM menu on ladder npc

	set .showtotal, 20; // show the length of ladder. Note : Maximum value = 128
	set .showpage, 10;	// set the views per page. Note : Maximum value = 128
	set .loweststreak, 3; // mininum streak count allow to show in highest streak ladder. Default 3 means must at least have killing spree streak to display in ladder
	set .lowestownage, 5; // mininum ownage count allow to show in longest ownage ladder. Default 5 means must at least have 5 ownage counts to display in ladder

	setarray .maptrigger$, // only these maps will trigger this script
		"all", // uncomment this to allow load all maps
		"guild_vs1",
		"guild_vs2",
		"guild_vs3",
		"guild_vs4",
		"guild_vs5";

//	anti-sit-killer system
	// a player must kill another player with this minimum <this number> base level to get the announcement and in the ladder.
	// Otherwise only have streak ended announcement and killed player's streak reset.
	// Its possible for a level 1 novice to kill a level 99 player and he/she will still get in the ladder
	// but a level 99 kill a level 1 player will get nothing
	// 0 - off this system ( default is 55, pk setting )
	set .lvltokill, 0;

	// when a player kill another same player <this number> times in a row, the player is warp back to save point.
	// and the player's streak, kills, and ownage count will deduct accordingly
	// 0 - off this system
	set .counttopunish, 6;

	// minimum level range to kill another player
	// eg. when set to 20, player level 99 needs to kill another player with minimum level of 79 to get announcement and increase the kill rank.
	// but a player with base level 50 kills a level 99 will also get the announcement
	// higher base level cannot kill lower level, but lower level can kill higher level
	// 0 - off this system
	set .minlvlrange, 0;


// Config ends ------------------------------------------------------------------------------------------

//	to prevent bug happen
	if ( .announce < 0 || .announce > 1 ) set .announce, 0;
	if ( .continue < 1 ) set .continue, 1;
	if ( .owncontinue < 1 ) set .owncontinue, 1;
	if ( .gmnokill <= 0 ) set .gmnokill, 100;
	if ( .lvltokill <= 1 ) set .lvltokill, 0;
	if ( .counttopunish <= 1 ) set .counttopunish, 0;
	set .maptriggersize, getarraysize(.maptrigger$);
	end;

//	script start.
OnPCKillEvent:
	if ( getgmlevel() >= .gmnokill ) end;
	getmapxy .@map$, .@x, .@y, 0;
	if ( .maptrigger$ != "all" ) {
		for ( set .@i, 0; .@i < .maptriggersize; set .@i, .@i +1 ) {
			if ( .@map$ == .maptrigger$[.@i] ) break;
		}
		if ( .@i == .maptriggersize ) end;
	}
	attachrid killedrid;
	if ( killerrid != getcharid(3) && ( .msg_die || .msg_kill ) ) {
		if ( .msg_die ) message strcharinfo(0),"You have been killed by "+ rid2name(killerrid);
		if ( .msg_kill ) message rid2name(killerrid),"You just killed "+ strcharinfo(0);
	}
	if ( @PlayersKilledStreak >= .holyshit )
		set .@streakname$,"Beyond Godlike";
	else if ( @PlayersKilledStreak >= .godlike )
		set .@streakname$,"Godlike";
	else if ( @PlayersKilledStreak >= .monsterkill )
		set .@streakname$,"Monster Kill";
	else if ( @PlayersKilledStreak >= .wickedsick )
		set .@streakname$,"Wicked Sick";
	else if ( @PlayersKilledStreak >= .unstoppable )
		set .@streakname$,"Unstoppable";
	else if ( @PlayersKilledStreak >= .megakill )
		set .@streakname$,"Mega-kill";
	else if ( @PlayersKilledStreak >= .dominating )
		set .@streakname$,"Dominating";
	else if ( @PlayersKilledStreak >= .killingspree )
		set .@streakname$,"Killing Spree";
	if ( @PlayersKilledStreak >= .killingspree && killerrid == getcharid(3) )
		announce strcharinfo(0) +" has ended "+( (sex)?"him":"her" )+" own "+ .@streakname$ +"["+ @PlayersKilledStreak +"] streak "+( (.announcemap)?("at "+ .@map$):""),16|.announce;
	else if ( @PlayersKilledStreak >= .killingspree )
		announce rid2name(killerrid) +" has ended "+ strcharinfo(0) +"'s "+ .@streakname$ +"["+ @PlayersKilledStreak +"] streak "+( (.announcemap)?("at "+ .@map$):""),16|.announce;
	else if ( .announcekill && killerrid != getcharid(3) )
		announce rid2name(killerrid) +" has pawned "+ strcharinfo(0) +"'s head "+( (.announcemap)?("at "+ .@map$):""),16|.announce;
	set @PlayersKilledStreak,0;
	set @dota_sql_deaths, @dota_sql_deaths +1;
	set @dota_multikills,0;
	query_sql "replace into pvpladder values ( "+ getcharid(0) +", '"+ escape_sql(strcharinfo(0)) +"', "+ @dota_sql_streaks +", "+ @dota_sql_kills +", "+ @dota_sql_deaths +", from_unixtime("+ @dota_sql_streaktime +") )";
	set .@killed_gid, getcharid(2);
	if ( .@killed_gid ) {
		setd ".dota_sql_"+ .@killed_gid +"_c", 0;
		if ( getd(".dota_sql_"+ .@killed_gid +"_h") )
			query_sql "replace into ownladder values ( "+ .@killed_gid +", '"+ escape_sql(getguildname(.@killed_gid)) +"', "+ getd(".dota_sql_"+ .@killed_gid +"_c") +", "+ getd(".dota_sql_"+ .@killed_gid +"_h") +", from_unixtime("+ getd(".dota_sql_"+ .@killed_gid +"_t") +") )";
	}
	if ( killerrid == getcharid(3) || baselevel < .lvltokill ) end;
	if ( .minlvlrange ) set .@killedlvl, baselevel;
	attachrid killerrid;
	if ( .minlvlrange && .@killedlvl + .minlvlrange < baselevel ) end;
	if ( .counttopunish ) {
		if ( @sitkillminute != gettime(2) ) {
			deletearray @sitkillid, 128;
			deletearray @sitkilltimes, 128;
			set @sitkillminute, gettime(2);
		}
		set .@sitkillsize, getarraysize(@sitkillid);
		for ( set .@i,0; .@i < .@sitkillsize; set .@i, .@i +1 ) {
			if ( @sitkillid[.@i] != killedrid ) continue;
			else {
				set @sitkilltimes[.@i], @sitkilltimes[.@i] +1 ;
				if ( @sitkilltimes[.@i] >= .counttopunish ) {
					warp "SavePoint",0,0;
					announce strcharinfo(0) +" , Stop killing "+ rid2name(killedrid) + " !!!",0;
					debugmes strcharinfo(0) +" is sit-killing "+ rid2name(killedrid) +" for "+ @sitkilltimes[.@i] + " times";
					logmes "is sit-killing "+ rid2name(killedrid) +" for "+ @sitkilltimes[.@i] +" times";
					if ( @PlayersKilledStreak == @dota_sql_streaks ) {
						set @dota_sql_streaks, @dota_sql_streaks +1 - .counttopunish;
						set @dota_sql_streaktime, gettimetick(2);
					}
					set @PlayersKilledStreak, @PlayersKilledStreak +1 - .counttopunish;
					set @dota_sql_kills, @dota_sql_kills +1 - .counttopunish;
					query_sql "replace into pvpladder values ( "+ getcharid(0) +", '"+ escape_sql(strcharinfo(0)) +"', "+ @dota_sql_streaks +", "+ @dota_sql_kills +", "+ @dota_sql_deaths +", from_unixtime("+ @dota_sql_streaktime +") )";
					set .@killer_gid, getcharid(2);
					if ( .@killer_gid ) {
						if ( getd(".dota_sql_"+ .@killer_gid +"_c") == getd(".dota_sql_"+ .@killer_gid +"_h") ) {
							setd ".dota_sql_"+ .@killer_gid +"_h", getd(".dota_sql_"+ .@killer_gid +"_h") +1 - .counttopunish;
							setd ".dota_sql_"+ .@killer_gid +"_t", gettimetick(2);
						}
						setd (".dota_sql_"+ .@killer_gid +"_c"), getd(".dota_sql_"+ .@killer_gid +"_c") +1 - .counttopunish;
						query_sql "replace into ownladder values ( "+ .@killer_gid +", '"+ escape_sql(getguildname(.@killer_gid)) +"', "+ getd(".dota_sql_"+ .@killer_gid +"_c") +", "+ getd(".dota_sql_"+ .@killer_gid +"_h") +", from_unixtime("+ getd(".dota_sql_"+ .@killer_gid +"_t") +") )";
					}
					end;
				}
				break;
			}
		}
		if ( .@i == .@sitkillsize ) {
			set @sitkillid[.@i], killedrid;
			set @sitkilltimes[.@i], 1;
		}
	}
	set @PlayersKilledStreak, @PlayersKilledStreak +1 ;
	set @dota_sql_kills, @dota_sql_kills +1 ;
	if ( @PlayersKilledStreak > @dota_sql_streaks ) {
		set @dota_sql_streaks, @PlayersKilledStreak;
		set @dota_sql_streaktime, gettimetick(2);
	}
	query_sql "replace into pvpladder values ( "+ getcharid(0) +", '"+ escape_sql(strcharinfo(0)) +"', "+ @dota_sql_streaks +", "+ @dota_sql_kills +", "+ @dota_sql_deaths +", from_unixtime("+ @dota_sql_streaktime +") )";
	if ( @PlayersKilledStreak == .killingspree )
		setarray .@streakname$,"killingspree.wav","is on a KILLING SPREE","!";
	else if ( @PlayersKilledStreak == .dominating )
		setarray .@streakname$,"dominating.wav","is DOMINATING","!";
	else if ( @PlayersKilledStreak == .megakill )
		setarray .@streakname$,"megakill.wav","has a MEGA KILL","!";
	else if ( @PlayersKilledStreak == .unstoppable )
		setarray .@streakname$,"unstoppable.wav","is UNSTOPPABLE","!!";
	else if ( @PlayersKilledStreak == .wickedsick )
		setarray .@streakname$,"wickedsick.wav","is WICKED SICK","!!";
	else if ( @PlayersKilledStreak == .monsterkill )
		setarray .@streakname$,"monsterkill.wav","has a MONSTER KILL","!!";
	else if ( @PlayersKilledStreak == .godlike )
		setarray .@streakname$,"godlike.wav","is GODLIKE","!!!";
	else if ( @PlayersKilledStreak >= .holyshit && ( (@PlayersKilledStreak - .holyshit) % .continue == 0 ) )
		setarray .@streakname$,"holyshit.wav","is BEYOND GODLIKE",". Someone KILL "+( (sex)?"HIM":"HER" ) +"!!!!!!";
	if ( .@streakname$[1] != "" ) {
		announce strcharinfo(0) +" "+ .@streakname$[1] +"["+ @PlayersKilledStreak +"] "+( (.announcemap)?("at "+ .@map$):"") + .@streakname$[2],16|.announce;
		if ( .sound == 1 ) soundeffectall .@streakname$[0],0,.@map$;
		else if ( .sound == 2 ) soundeffectall .@streakname$[0],0;
		else if ( .sound == 3 ) soundeffect .@streakname$[0],0;
	}
	set @dota_multikills, @dota_multikills + 1;
	deltimer "DOTAPVP::OnStreakReset";
	addtimer 18000,"DOTAPVP::OnStreakReset";
	set .@killer_gid, getcharid(2);
	if ( .@killer_gid && .@killer_gid != .@killed_gid ) {
		setd ".dota_sql_"+ .@killer_gid +"_c", getd(".dota_sql_"+ .@killer_gid +"_c") +1 ;
		if ( getd(".dota_sql_"+ .@killer_gid +"_c") > getd(".dota_sql_"+ .@killer_gid +"_h") ) {
			setd ".dota_sql_"+ .@killer_gid +"_h", getd(".dota_sql_"+ .@killer_gid +"_c");
			setd ".dota_sql_"+ .@killer_gid +"_t", gettimetick(2);
		}
		query_sql "replace into ownladder values ( "+ .@killer_gid +", '"+ escape_sql(getguildname(.@killer_gid)) +"', "+ getd(".dota_sql_"+ .@killer_gid +"_c") +", "+ getd(".dota_sql_"+ .@killer_gid +"_h") +", from_unixtime("+ getd(".dota_sql_"+ .@killer_gid +"_t") +") )";
	}
	set .@dota_multikills, @dota_multikills;
	set .@origin, getcharid(3);
	sleep 1500;
	if ( .@killer_gid && .@killer_gid != .@killed_gid && getd(".dota_sql_"+ .@killer_gid +"_c") >= .owned && ( ( getd(".dota_sql_"+ .@killer_gid +"_c") - .owned ) % .owncontinue == 0 ) ) {
		if ( .announce ) mapannounce .@map$, "The guild ["+ getguildname(.@killer_gid) +"] is OWNING["+ getd(".dota_sql_"+ .@killer_gid +"_c") +"] !!!",16;
		else announce "The guild ["+ getguildname(.@killer_gid) +"] is OWNING["+ getd(".dota_sql_"+ .@killer_gid +"_c") +"] !!!",16;
		if ( .sound == 1 ) soundeffectall "ownage.wav",0,.@map$;
		else if ( .sound == 2 ) soundeffectall "ownage.wav",0;
		else if ( .sound == 3 && attachrid(.@origin) ) soundeffect "ownage.wav",0;
	}
	sleep 1250;
	if ( !attachrid(.@origin) ) end;
	if ( .@dota_multikills == 2 ) {
		if ( .announce ) mapannounce .@map$, strcharinfo(0) +" just got a Double Kill !",16;
		else announce strcharinfo(0) +" just got a Double Kill !",16;
		if ( .sound == 1 ) soundeffectall "doublekill.wav",0,.@map$;
		else if ( .sound == 2 ) soundeffectall "doublekill.wav",0;
		else if ( .sound == 3 ) soundeffect "doublekill.wav",0;
	}
	else if ( .@dota_multikills == 3 ) {
		if ( .announce ) mapannounce .@map$, strcharinfo(0) +" just got a Triple Kill !!!",16;
		else announce strcharinfo(0) +" just got a Triple Kill !!!",16;
		if ( .sound == 1 ) soundeffectall "triplekill.wav",0,.@map$;
		else if ( .sound == 2 ) soundeffectall "triplekill.wav",0;
		else if ( .sound == 3 ) soundeffect "triplekill.wav",0;
	}
	else if ( .@dota_multikills == 4 ) {
		if ( .announce ) mapannounce .@map$, strcharinfo(0) +" just got a Ultra Kill !!!",16;
		else announce strcharinfo(0) +" just got a Ultra Kill !!!",16;
		if ( .sound == 1 ) soundeffectall "ultrakill.wav",0,.@map$;
		else if ( .sound == 2 ) soundeffectall "ultrakill.wav",0;
		else if ( .sound == 3 ) soundeffect "ultrakill.wav",0;
	}
	else if ( .@dota_multikills >= 5 ) {
		if ( .announce ) mapannounce .@map$, strcharinfo(0) +" is on a Rampage !!!",16;
		else announce strcharinfo(0) +" is on a Rampage !!!",16;
		if ( .sound == 1 ) soundeffectall "rampage.wav",0,.@map$;
		else if ( .sound == 2 ) soundeffectall "rampage.wav",0;
		else if ( .sound == 3 ) soundeffect "rampage.wav",0;
	}
	end;
OnStreakReset:
	set @dota_multikills, 0;
	end;
OnWhisperGlobal:
	if ( @spam_dotapvp + 3 >= gettimetick(2) ) // 3 seconds interval so player don spam this command
		end;
	set @spam_dotapvp, gettimetick(2);
	if ( @dota_sql_kills == 0 && @dota_sql_deaths == 0 )
		query_sql "select kills, deaths, streaks, unix_timestamp(streaktime) from pvpladder where char_id = "+ getcharid(0), @dota_sql_kills, @dota_sql_deaths, @dota_sql_streaks, @dota_sql_streaktime;
	if ( @dota_sql_kills || @dota_sql_deaths ) {
		dispbottom "Your current Streak      : "+ @PlayersKilledStreak;
		dispbottom "Your total Kills               : "+ @dota_sql_kills;
		dispbottom "Your total Deaths          : "+ @dota_sql_deaths;
		dispbottom "Your highest Streak      : "+ @dota_sql_streaks;
		query_sql "select date_format( from_unixtime("+ @dota_sql_streaktime +"),'%a %e/%c/%y %r')", .@time1$;
		dispbottom "Your highest Streak on : "+ .@time1$;
	}
	else
		dispbottom "You are not in the pvp ladder yet.";
	if ( getcharid(2) ) {
		if ( getd(".dota_sql_"+ getcharid(2) +"_h") == 0 ) {
			query_sql "select currentown, highestown, unix_timestamp(owntime) from ownladder where guild_id = "+ getcharid(2), .@c, .@h, .@t;
			setd ".dota_sql_"+ getcharid(2) +"_c", .@c;
			setd ".dota_sql_"+ getcharid(2) +"_h", .@h;
			setd ".dota_sql_"+ getcharid(2) +"_t", .@t;
		}
		if ( getd(".dota_sql_"+ getcharid(2) +"_h") ) {
			dispbottom "Your guild current Own      : "+ getd(".dota_sql_"+ getcharid(2) +"_c");
			dispbottom "Your guild highest Own      : "+ getd(".dota_sql_"+ getcharid(2) +"_h");
			query_sql "select date_format( from_unixtime("+ getvariableofnpc( getd(".dota_sql_"+ getcharid(2) +"_t"), "DOTAPVP" ) +"),'%a %e/%c/%y %r')", .@time2$;
			dispbottom "Your guild highest Own on : "+ .@time2$;
		}
		else
			dispbottom "Your guild is not in the ladder yet.";
	}
	end;
OnPCLoginEvent:
	if ( .maptrigger$ != "all" ) end;
OnPCLoadMapEvent:
	if ( @dota_sql_kills == 0 && @dota_sql_deaths == 0 ) {
		if ( .maptrigger$ != "all" ) {
			getmapxy .@map$, .@x, .@y, 0;
			for ( set .@i, 0; .@i < .maptriggersize; set .@i, .@i +1 ) {
				if ( .@map$ == .maptrigger$[.@i] ) break;
			}
			if ( .@i == .maptriggersize ) end;
		}
		query_sql "select kills, deaths, streaks, unix_timestamp(streaktime) from pvpladder where char_id = "+ getcharid(0), @dota_sql_kills, @dota_sql_deaths, @dota_sql_streaks, @dota_sql_streaktime;
	}
	if ( getcharid(2) && getd(".dota_sql_"+ getcharid(2) +"_h") == 0 ) {
		query_sql "select currentown, highestown, unix_timestamp(owntime) from ownladder where guild_id = "+ getcharid(2), .@c, .@h, .@t;
		setd ".dota_sql_"+ getcharid(2) +"_c", .@c;
		setd ".dota_sql_"+ getcharid(2) +"_h", .@h;
		setd ".dota_sql_"+ getcharid(2) +"_t", .@t;
	}
	end;
}

-	script	PvP-StatsViewer	-1,{
	set .@npcname$, strnpcinfo(0);
	while (1) {
		mes "["+ .@npcname$ +"]";
		mes "สวัสดี "+ strcharinfo(0) +"...";
		mes "ฉันสามารถแสดงสถิติ PVP ของคุณได้ ถ้าคุณต้องการ";
		next;
		switch ( select ( "ฆ่ามากที่สุด", "ฆ่าต่อเนื่อง", "ครองนานที่สุด", "ข้อมูลของตัวเอง", "คำอธิบาย" ) ) {
			case 1:
				set .@nb, query_sql("select name, kills, deaths from pvpladder order by kills desc limit "+ getvariableofnpc(.showtotal,"DOTAPVP"), .@name$, .@kills, .@deaths);
				if ( .@nb == 0 ) {
					mes "["+ .@npcname$ +"]";
					mes "The ladder currently is empty.";
					next;
				}
				for ( set .@j,0; .@j < .@nb; set .@j, .@j + getvariableofnpc(.showpage,"DOTAPVP") ) {
					mes "["+ .@npcname$ +"]";
					for ( set .@i, .@j; .@i < (getvariableofnpc(.showpage,"DOTAPVP") + .@j) && .@i < .@nb; set .@i, .@i + 1 ) {
						mes "^996600"+ (.@i+1) +": ^006699"+ .@name$[.@i] +" ^00AA00["+ .@kills[.@i] +"] ^FF0000<"+ .@deaths[.@i] +">^000000";
					}
					next;
				}
				break;
			case 2:
				set .@nb, query_sql("select name, streaks, date_format(streaktime,'%a %e/%c/%y %r') from pvpladder where streaks >= "+ getvariableofnpc(.loweststreak,"DOTAPVP") +" order by streaks desc limit "+ getvariableofnpc(.showtotal,"DOTAPVP"), .@name$, .@streak, .@time$);
				if ( .@nb == 0 ) {
					mes "["+ .@npcname$ +"]";
					mes "The ladder currently is empty.";
					next;
				}
				for ( set .@j,0; .@j < .@nb; set .@j, .@j + getvariableofnpc(.showpage,"DOTAPVP") ) {
					mes "["+ .@npcname$ +"]";
					for ( set .@i, .@j; .@i < (getvariableofnpc(.showpage,"DOTAPVP") + .@j) && .@i < .@nb; set .@i, .@i + 1 ) {
						mes "^996600"+ (.@i+1) +": ^006699"+ .@name$[.@i] +" ^70AC11{"+ .@streak[.@i] +"} ^000000on :";
						mes "    ^EE8800"+ .@time$[.@i] +"^000000";
					}
					next;
				}
				break;
			case 3:
				set .@nb, query_sql("select name, highestown, date_format(owntime,'%a %e/%c/%y %r') from ownladder where highestown >= "+ getvariableofnpc(.lowestownage,"DOTAPVP") +" order by highestown desc limit "+ getvariableofnpc(.showtotal,"DOTAPVP"), .@name$, .@owned, .@time$);
				if ( .@nb == 0 ) {
					mes "["+ .@npcname$ +"]";
					mes "The ladder currently is empty.";
					next;
				}
				for ( set .@j,0; .@j < .@nb; set .@j, .@j + getvariableofnpc(.showpage,"DOTAPVP") ) {
					mes "["+ .@npcname$ +"]";
					for ( set .@i, .@j; .@i < (getvariableofnpc(.showpage,"DOTAPVP") + .@j) && .@i < .@nb; set .@i, .@i + 1 ) {
						mes "^996600"+ (.@i+1) +": ^006699"+ .@name$[.@i] +" ^00AAAA("+ .@owned[.@i] +") ^000000on :";
						mes "    ^EE8800"+ .@time$[.@i] +"^000000";
					}
					next;
				}
				break;
			case 4:
				if ( @dota_sql_kills == 0 && @dota_sql_deaths == 0 )
					query_sql "select kills, deaths, streaks, unix_timestamp(streaktime), date_format(streaktime,'%a %e/%c/%y %r') from pvpladder where char_id = "+ getcharid(0), @dota_sql_kills, @dota_sql_deaths, @dota_sql_streaks, @dota_sql_streaktime, .@time1$;
				mes "["+ .@npcname$ +"]";
				if ( @dota_sql_kills == 0 && @dota_sql_deaths == 0 )
					mes "You not yet kill any player.";
				else {
					mes "Your Current Streak : ^70AC11{"+ @PlayersKilledStreak +"}^000000";
					mes "Your Total Kills : ^00AA00["+ @dota_sql_kills +"]^000000";
					mes "Your Death Counts : ^FF0000<"+ @dota_sql_deaths +">^000000";
					if ( @dota_sql_kills || @dota_sql_streaks ) {
						mes "Highest Streak was ^70AC11{"+ @dota_sql_streaks +"}^000000 on :";
						query_sql "select date_format( from_unixtime("+ @dota_sql_streaktime +"),'%a %e/%c/%y %r')", .@time1$;
						mes "    ^EE8800"+ .@time1$ +"^000000";
					}
				}
				next;
				if ( getcharid(2) ) {
					if ( getvariableofnpc( getd(".dota_sql_"+ getcharid(2) +"_h"), "DOTAPVP" ) == 0 ) {
						query_sql "select currentown, highestown, unix_timestamp(owntime) from ownladder where guild_id = "+ getcharid(2), .@c, .@h, .@t;
						set getvariableofnpc( getd(".dota_sql_"+ getcharid(2) +"_c"), "DOTAPVP" ), .@c;
						set getvariableofnpc( getd(".dota_sql_"+ getcharid(2) +"_h"), "DOTAPVP" ), .@h;
						set getvariableofnpc( getd(".dota_sql_"+ getcharid(2) +"_t"), "DOTAPVP" ), .@t;
					}
					mes "["+ .@npcname$ +"]";
					if ( getvariableofnpc( getd(".dota_sql_"+ getcharid(2) +"_h"), "DOTAPVP" ) == 0 ) {
						mes "Your guild not yet kill any player.";
					} else {
						mes "Your guild name : ^006699"+ strcharinfo(2) +"^000000";
						mes "Current Owning  : ^00AAAA("+ getvariableofnpc( getd(".dota_sql_"+ getcharid(2) +"_c"), "DOTAPVP" ) +")^000000";
						mes "Longest Ownage was ^00AAAA("+ getvariableofnpc( getd(".dota_sql_"+ getcharid(2) +"_h"), "DOTAPVP" ) + ")^000000 on :";
						query_sql "select date_format( from_unixtime("+ getvariableofnpc( getd(".dota_sql_"+ getcharid(2) +"_t"), "DOTAPVP" ) +"),'%a %e/%c/%y %r')", .@time2$;
						mes "    ^EE8800"+ .@time2$ +"^000000";
					}
					next;
				}
				break;
			case 5:
				mes "["+ .@npcname$ +"]";
				mes "คำอธิบายสำหรับผู้ที่ฆ่าที่สุด:";
				mes " ";
				mes "^996600Rank. ^006699NAME ^00AA00[Total Kills] ^FF0000<Deaths>^000000";
				mes " ";
				mes "--------------------------------";
				mes " ";
				mes "^00AA00ฆ่ามากที่สุด^000000 คะแนนจะเพิ่มเมื่อผู้เล่นฆ่าผู้เล่นคนอื่น";
				mes " ";
				mes "^FF0000การตาย^000000 นับเพิ่มขึ้นเมื่อผู้เล่นถูกสังหารโดยผู้เล่นอื่นหรือการฆ่าตัวตาย (เช่น Grand Cross)";
				mes " ";
				mes "ผู้เล่นที่ถูกสังหารโดยมอนสเตอร์ homunculus หรือสัตว์เลี้ยงจะไม่เพิ่มการฆ่าหรือการเสียชีวิตนับ";
				next;
				mes "["+ .@npcname$ +"]";
				mes "คำอธิบายสำหรับ High Streak:";
				mes " ";
				mes "^996600Rank. ^006699NAME ^70AC11{Highest Streak} ^000000on :";
				mes "    ^EE8800TIME^000000";
				mes " ";
				mes "--------------------------------";
				mes " ";
				mes "^70AC11ฆ่าต่อเนื่อง^000000 คะแนนมีการเพิ่มทุกครั้งที่ผู้เล่นฆ่าผู้เล่นรายอื่น จะถูกรีเซ็ตเมื่อออกจากระบบถูกฆ่าโดยผู้เล่นคนอื่นหรือการฆ่าตัวตาย (เช่นการเสียสละ)";
				mes " ";
				mes "จากนั้นบันทึกในเซิร์ฟเวอร์ ^EE8800เวลา^000000 ที่ผู้เล่นคนนั้นมีคะแนนสูงสุด";
				mes " ";
				mes "ผู้เล่นที่ถูกสังหารโดยมอนสเตอร์ homunculus หรือสัตว์เลี้ยงจะไม่สามารถรีเซ็ตครีเอทีปได้";
				mes " ";
				mes "--------------------------------";
				mes " ";
				mes "การฆ่าที่จะได้รับประกาศคือประเภท:";
				mes "^70AC11"+ getvariableofnpc(.killingspree,"DOTAPVP") +"^000000 : Killing Spree";
				mes "^70AC11"+ getvariableofnpc(.dominating,"DOTAPVP") +"^000000 : Dominating";
				mes "^70AC11"+ getvariableofnpc(.megakill,"DOTAPVP") +"^000000 : Mega Kill";
				mes "^70AC11"+ getvariableofnpc(.unstoppable,"DOTAPVP") +"^000000 : Unstoppable";
				mes "^70AC11"+ getvariableofnpc(.wickedsick,"DOTAPVP") +"^000000 : Wicked Sick";
				mes "^70AC11"+ getvariableofnpc(.monsterkill,"DOTAPVP") +"^000000 : Monster Kill";
				mes "^70AC11"+ getvariableofnpc(.godlike,"DOTAPVP") +"^000000 : Godlike";
				mes "^70AC11"+ getvariableofnpc(.holyshit,"DOTAPVP") +"^000000 : Beyond Godlike";
				next;
				mes "["+ .@npcname$ +"]";
				mes "คำอธิบายเพื่อการครองนานที่สุด:";
				mes " ";
				mes "^996600ลำดับ ^006699ชื่อ ^00AAAA(ครองนานที่สุด) ^000000on :";
				mes "    ^EE8800TIME^000000";
				mes " ";
				mes "--------------------------------";
				mes " ";
				mes "^00AAAAOwnage^000000 เพิ่มทุกครั้งที่สมาชิกกิลด์ฆ่าผู้เล่นรายอื่นที่ไม่ได้เป็นสมาชิกของเขา / เธอ จะมีการตั้งค่าใหม่เมื่อสมาชิก guild คนใดคนหนึ่งถูกสังหารโดยผู้เล่นคนใดคนหนึ่งรวมถึงสมาชิก guild ของเขา";
				mes " ";
				mes "แล้วบันทึกในเซิร์ฟเวอร์ ^ EE8800เวลา ^000000 เมื่อกิลด์มีค่าตัวที่ยาวนานที่สุด";
				mes " ";
				mes "หากเซิร์ฟเวอร์มีการปิดเพื่อบำรุงรักษา อันดับจะเป็นของคนล่าสุด";
				mes " ";
				mes "สมาชิกกิลด์ที่ถูกมอนสเตอร์ homunculus หรือสัตว์เลี้ยงเสียชีวิตจะไม่สามารถรีเซ็ตการนับตัวเองได้";
				next;
				if ( getvariableofnpc(.lvltokill,"DOTAPVP") ) {
					mes "["+ .@npcname$ +"]";
					mes "คุณต้องฆ่าผู้เล่นอื่นที่มีระดับพื้นฐานต่ำสุดคือ "+ getvariableofnpc(.lvltokill,"DOTAPVP") +" เพื่อให้ได้ประกาศหรือเลื่อนขั้น";
					mes " ";
					mes "เป็นไปได้สำหรับผู้เริ่มต้นระดับ 1 จะฆ่าผู้เล่นระดับพื้นฐาน 99 คนและยังสามารถเข้าสู่บันไดได้";
					mes "อย่างไรก็ตามเมื่อผู้เล่นระดับ 99 ฆ่ามือใหม่ระดับ 1 จะไม่ได้อะไรเลย";
					next;
				}
				if ( getvariableofnpc(.counttopunish,"DOTAPVP") ) {
					mes "["+ .@npcname$ +"]";
					mes "ผู้เล่น noob บางคนพยายามที่จะฆ่าคนคนนั้นซ้ำแล้วซ้ำอีกด้วยความหวังว่าชื่อของเขาจะปรากฏในการเลื่อนขั้น";
					mes "อย่างไรก็ตามหากคุณพยายามทำ ชื่อของคุณจะประกาศต่อสาธารณะและการกระทำของคุณจะถูกบันทึกลงในเซิร์ฟเวอร์เพื่อแจ้งให้ GM ทราบ";
					next;
				}
				if ( getvariableofnpc(.minlvlrange,"DOTAPVP") ) {
					mes "["+ .@npcname$ +"]";
					mes "เมื่อคุณฆ่าผู้เล่นอื่นที่ต่ำกว่าระดับฐานคุณช่องว่างระดับฐานระหว่างคุณกับผู้เล่นนั้นจะต้องไม่เกิน "+ getvariableofnpc(.minlvlrange,"DOTAPVP") +".";
					mes " ";
					if ( getvariableofnpc(.minlvlrange,"DOTAPVP") >= 200)
						mes "หรือถ้าระดับพื้นฐานของคุณคือ 500 ผู้เล่นที่คุณฆ่าต้องมีระดับอย่างน้อย "+( 500 - getvariableofnpc(.minlvlrange,"DOTAPVP") )+"แล้วคุณจะได้รับประกาศและเลื่อขั้นเท่านั้น";
					else if ( getvariableofnpc(.minlvlrange,"DOTAPVP") >= 70)
						mes "หรือถ้าระดับพื้นฐานของคุณคือ 255 ผู้เล่นที่คุณฆ่าต้องมีระดับอย่างน้อย "+( 255 - getvariableofnpc(.minlvlrange,"DOTAPVP") )+"แล้วคุณจะได้รับประกาศและใเลื่อนขั้นเท่านั้น";
					else
						mes "กล่าวอีกนัยหนึ่งถ้าระดับพื้นฐานของคุณคือ 99 ผู้เล่นที่คุณฆ่าต้องมีระดับอย่างน้อย "+( 99 - getvariableofnpc(.minlvlrange,"DOTAPVP") )+" แล้วคุณจะได้รับประกาศและเลื่อนขั้นเท่านั้น";
					mes "ผู้เล่นลัดับสูงฆ่าผู้เล่นระดับต่ำว่าจะไม่ได้อะไร แต่ผู้เล่นระดับล่างจะฆ่าระดับที่สูงขึ้นจะได้รับการประกาศ";
					next;
				}
				break;
		}
	}
}